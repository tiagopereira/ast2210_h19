{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Theses pages contain the notes and description of the Solar Lab assignment for AST2210. Please read carefully to make sure you understand the background materials, what is expected from this assignment, and the necessary software to run it. Required software \u00b6 This assignment is primarily a computational task, and should be written using the Python programming language. While it is possible to complete most tasks using different programming languages, these notes are centred around Python libraries that simplify your work. To encourage good scientific practices, your report should be in the form of a Jupyter notebook (see template ), and you need to use Jupyterlab or the Jupyter notebook . You will need the following software: Python 3.x Jupyterlab / Jupyter notebook Astropy , Sunpy , and IRISpy packages More details on obtaining and installing these packages can be found in the Preparation section. How to read these notes \u00b6 After the Preparation section, these notes are written in a notebook fashion to encourage experimentation. Explanations of different procedures are included in between Python code blocks such as the following: import numpy as np print ( np . arange ( 5 )) You can copy paste the code into notebook cells and run the same commands to ensure you get the same results and get a feel for how it works. To make this task even easier, the sections are also available to download as a Jupyter notebook, which you can open in your computer and run directly. We recommend you run through all the code examples before getting started on the assignment. The final section details the assignment questions and format. Data and Observatories \u00b6 In this project you will work with observations of the Sun taken by two NASA space telescopes: the Atmospheric Imaging Assembly (AIA) and the Interface Region Imaging Spectrograph (IRIS). During your progress through these notes and for your assignment you will need to download hundreds of megabytes of data, so make sure you plan accordingly to ensure you don't run out of time while waiting for the data to download! The largest data volume will be downloaded before you start and is described in Preparation , but you will also download other that on the go, and the specific amount will depend on your curiosity. Below is a brief introduction to the two telescopes we will use. Atmospheric Imaging Assembly \u00b6 AIA is a part of the much larger Solar Dynamics Observatory (SDO), which was launched in 2010 and is one of the largest and most expensive solar telescopes every launched. AIA is an array 4 telescopes with 20 cm apertures, which give an angular resolution of about 1\u2033 (arcsec). It uses a variety of filters in parallel to gather 8 images of the Sun every 12 seconds. Each image covers the whole Sun and has a resolution of 4096x4096 pixels (16 Megapixels). As of 2018, AIA has collected more than 178 million images of the Sun. Angular vs. spatial resolution In Astronomy, we use angular resolution as the measure of resolving power of a telescope. This is typically measured in arc seconds of a degree (\u2033) and tells us the smallest aperture in the sky that the telescope can distinguish. To convert from angular to spatial resolution we need to know the distance to the far-away object. For the Sun, 1\u2033 translates to about 725 km on the solar surface. This is the equivalent of seeing a human hair held 10 m away. The different filters on AIA give us a view of different layers of the solar atmosphere. There is a lot of activity in the Sun, and by using narrow-band filters we can study different layers, or temperatures. AIA channel Source ion Region of solar atmosphere Characteristic temperature 450.0 nm continuum Photosphere 5777 5777 K 170.0 nm continuum Temperature minimum, photosphere 5000 5000 K 30.4 nm He II Chromosphere & transition region 50\\,000 50\\,000 K 160.0 nm C IV + continuum Transition region & upper photosphere 10^5 10^5 & 5000 5000 K 17.1 nm Fe IX Quiet corona, upper transition region 6.3\u00d710^5 6.3\u00d710^5 K 19.3 nm Fe XII, XXIV Corona & hot flare plasma 1.2\u00d710^6 1.2\u00d710^6 & 2\u00d710^7 2\u00d710^7 K 21.1 nm Fe XIV Active region corona 2\u00d710^6 2\u00d710^6 K 33.5 nm Fe XVI Active region corona 2.5\u00d710^6 2.5\u00d710^6 K 9.4 nm Fe XVIII Flaring regions 6.3\u00d710^6 6.3\u00d710^6 K 13.1 nm Fe VIII, XX, XXIII Flaring regions 4\u00d710^5 4\u00d710^5 , 10^7 10^7 & 1.6\u00d710^7 1.6\u00d710^7 K The names of the AIA channels are often the wavelengths in \u00c5 (e.g. 171, 304, 1600). You can see live AIA images at the Sun Today (and also look at archives). Interface Region Imaging Spectrograph \u00b6 IRIS is a NASA small mission explorer that was launched in 2013. While much smaller than AIA, IRIS is able to study in detail the fine structure of the solar atmosphere, from the photosphere, chromosphere, and transition region. Like AIA, IRIS also has a 20 cm aperture telescope, but its angular resolution is 0\u2033.33. This is achieved by having a much smaller field of view (maximum 175\u2033x175\u2033). Besides images, IRIS has a spectrograph that observes in two bands: far UV (133.1 - 140.7 nm) and near UV (278.2 - 283.5 nm). The IRIS imager is called Slit Jaw Imager (SJI) and has the following filters: IRIS channel Source ion Region of solar atmosphere Characteristic temperature 283.2 nm continuum Photosphere 5777 5777 K 279.6 nm Mg II k Chromosphere 10\\,000 10\\,000 K 140.0 nm Si IV Transition region 80\\,000 80\\,000 K 133.0 nm C II + Fe XXI Transition region & flaring corona 15\\,000 15\\,000 & 10^7 10^7 K Although the most detailed information from IRIS comes from its spectra, for this project we will only work with SJI images. The Institute of Theoretical Astrophysics has been a partner of the IRIS mission since its inception. Members of the solar group are involved with the interpretation of IRIS data, and the Institute has a local mirror of IRIS data, at the Hinode Science Data Centre Europe . You can read an article about our involvement with IRIS (in Norwegian). More information about IRIS on the mission website .","title":"Introduction"},{"location":"#introduction","text":"Theses pages contain the notes and description of the Solar Lab assignment for AST2210. Please read carefully to make sure you understand the background materials, what is expected from this assignment, and the necessary software to run it.","title":"Introduction"},{"location":"#required-software","text":"This assignment is primarily a computational task, and should be written using the Python programming language. While it is possible to complete most tasks using different programming languages, these notes are centred around Python libraries that simplify your work. To encourage good scientific practices, your report should be in the form of a Jupyter notebook (see template ), and you need to use Jupyterlab or the Jupyter notebook . You will need the following software: Python 3.x Jupyterlab / Jupyter notebook Astropy , Sunpy , and IRISpy packages More details on obtaining and installing these packages can be found in the Preparation section.","title":"Required software"},{"location":"#how-to-read-these-notes","text":"After the Preparation section, these notes are written in a notebook fashion to encourage experimentation. Explanations of different procedures are included in between Python code blocks such as the following: import numpy as np print ( np . arange ( 5 )) You can copy paste the code into notebook cells and run the same commands to ensure you get the same results and get a feel for how it works. To make this task even easier, the sections are also available to download as a Jupyter notebook, which you can open in your computer and run directly. We recommend you run through all the code examples before getting started on the assignment. The final section details the assignment questions and format.","title":"How to read these notes"},{"location":"#data-and-observatories","text":"In this project you will work with observations of the Sun taken by two NASA space telescopes: the Atmospheric Imaging Assembly (AIA) and the Interface Region Imaging Spectrograph (IRIS). During your progress through these notes and for your assignment you will need to download hundreds of megabytes of data, so make sure you plan accordingly to ensure you don't run out of time while waiting for the data to download! The largest data volume will be downloaded before you start and is described in Preparation , but you will also download other that on the go, and the specific amount will depend on your curiosity. Below is a brief introduction to the two telescopes we will use.","title":"Data and Observatories"},{"location":"#atmospheric-imaging-assembly","text":"AIA is a part of the much larger Solar Dynamics Observatory (SDO), which was launched in 2010 and is one of the largest and most expensive solar telescopes every launched. AIA is an array 4 telescopes with 20 cm apertures, which give an angular resolution of about 1\u2033 (arcsec). It uses a variety of filters in parallel to gather 8 images of the Sun every 12 seconds. Each image covers the whole Sun and has a resolution of 4096x4096 pixels (16 Megapixels). As of 2018, AIA has collected more than 178 million images of the Sun. Angular vs. spatial resolution In Astronomy, we use angular resolution as the measure of resolving power of a telescope. This is typically measured in arc seconds of a degree (\u2033) and tells us the smallest aperture in the sky that the telescope can distinguish. To convert from angular to spatial resolution we need to know the distance to the far-away object. For the Sun, 1\u2033 translates to about 725 km on the solar surface. This is the equivalent of seeing a human hair held 10 m away. The different filters on AIA give us a view of different layers of the solar atmosphere. There is a lot of activity in the Sun, and by using narrow-band filters we can study different layers, or temperatures. AIA channel Source ion Region of solar atmosphere Characteristic temperature 450.0 nm continuum Photosphere 5777 5777 K 170.0 nm continuum Temperature minimum, photosphere 5000 5000 K 30.4 nm He II Chromosphere & transition region 50\\,000 50\\,000 K 160.0 nm C IV + continuum Transition region & upper photosphere 10^5 10^5 & 5000 5000 K 17.1 nm Fe IX Quiet corona, upper transition region 6.3\u00d710^5 6.3\u00d710^5 K 19.3 nm Fe XII, XXIV Corona & hot flare plasma 1.2\u00d710^6 1.2\u00d710^6 & 2\u00d710^7 2\u00d710^7 K 21.1 nm Fe XIV Active region corona 2\u00d710^6 2\u00d710^6 K 33.5 nm Fe XVI Active region corona 2.5\u00d710^6 2.5\u00d710^6 K 9.4 nm Fe XVIII Flaring regions 6.3\u00d710^6 6.3\u00d710^6 K 13.1 nm Fe VIII, XX, XXIII Flaring regions 4\u00d710^5 4\u00d710^5 , 10^7 10^7 & 1.6\u00d710^7 1.6\u00d710^7 K The names of the AIA channels are often the wavelengths in \u00c5 (e.g. 171, 304, 1600). You can see live AIA images at the Sun Today (and also look at archives).","title":"Atmospheric Imaging Assembly"},{"location":"#interface-region-imaging-spectrograph","text":"IRIS is a NASA small mission explorer that was launched in 2013. While much smaller than AIA, IRIS is able to study in detail the fine structure of the solar atmosphere, from the photosphere, chromosphere, and transition region. Like AIA, IRIS also has a 20 cm aperture telescope, but its angular resolution is 0\u2033.33. This is achieved by having a much smaller field of view (maximum 175\u2033x175\u2033). Besides images, IRIS has a spectrograph that observes in two bands: far UV (133.1 - 140.7 nm) and near UV (278.2 - 283.5 nm). The IRIS imager is called Slit Jaw Imager (SJI) and has the following filters: IRIS channel Source ion Region of solar atmosphere Characteristic temperature 283.2 nm continuum Photosphere 5777 5777 K 279.6 nm Mg II k Chromosphere 10\\,000 10\\,000 K 140.0 nm Si IV Transition region 80\\,000 80\\,000 K 133.0 nm C II + Fe XXI Transition region & flaring corona 15\\,000 15\\,000 & 10^7 10^7 K Although the most detailed information from IRIS comes from its spectra, for this project we will only work with SJI images. The Institute of Theoretical Astrophysics has been a partner of the IRIS mission since its inception. Members of the solar group are involved with the interpretation of IRIS data, and the Institute has a local mirror of IRIS data, at the Hinode Science Data Centre Europe . You can read an article about our involvement with IRIS (in Norwegian). More information about IRIS on the mission website .","title":"Interface Region Imaging Spectrograph"},{"location":"IRIS/","text":"Download this page as a Jupyter notebook. IRIS and AIA \u00b6 To work with IRIS data in Python we will make use of the IRISPy package. IRISPy is an affiliated package of SunPy. Initialisation \u00b6 % matplotlib inline from matplotlib import pyplot as plt from matplotlib.patches import Polygon import numpy from irispy.sji import read_iris_sji_level2_fits import sunpy.map from sunpy.instr.aia import aiaprep from sunpy.time import parse_time from astropy.coordinates import SkyCoord from astropy import units as u # To make a larger figure plt . rcParams [ 'figure.figsize' ] = [ 10 , 9 ] import warnings warnings . filterwarnings ( \"ignore\" ) Working with IRIS SJI files \u00b6 Let us start by loading the IRIS dataset that was taken at a similar time to the AIA images we worked on earlier. IRIS has both a spectrograph and an imager, but here we'll work only with the imager (SJI = Slit-Jaw Image). These images show the position of the spectrograph slit with respect to the solar image. The slit is the central, vertical dark line in the images. To read IRIS SJI files, we'll make use of the read_iris_sji_level2_fits from IRISPy : sji = read_iris_sji_level2_fits ( \"iris_l2_20140919_051712_3860608353_SJI_2832_t000.fits\" ) sji INFO : uncertainty should have attribute uncertainty_type . [ astropy . nddata . nddata ] IRISMapCube --------- Observatory : IRIS Instrument : SJI Bandpass : 2832.0 Obs . Start : 2014 - 09 - 19 T05 : 17 : 12.610000 Obs . End : 2014 - 09 - 19 T07 : 14 : 54.895000 Instance Start : 2014 - 09 - 19 T05 : 17 : 31.110000 Instance End : 2014 - 09 - 19 T07 : 13 : 24.610000 Total Frames in Obs .: 65 IRIS Obs . id : 3860608353 IRIS Obs . Description : Large sit - and - stare 0.3 x120 1 s C II Mg II h / k Mg II w s Deep x Cube dimensions : [ 65 . 387 . 364 .] pix Axis Types : ( None , 'custom:pos.helioprojective.lat' , 'custom:pos.helioprojective.lon' ) This loads the data into an IRISMapCube object. Unlike AIA, an IRIS SJI file contains many images. In the summary above, we can see that this sequence on 2014-09-19 goes from 05:17:31 to 07:13:24 and contains 65 images. Each image has dimensions of (nx, ny) = (387, 364). Like Map in SunPy, IRISMapCube contains additional metadata, including the coordinates of the observation. It also has a .plot () method, that allows a quick plotting of images: sji [ 0 ] . plot () plt . show () Here, we are plotting the first image in the sequence. It is also possible to simply call sji.plot() , which will return an animator instance that can play a movie of all images when an interactive matplotlib backend is used (here we are using inline , which works better in the browser, but is not interactive). The plot does not look as complete as sunpy.map.Map.plot() because IRISPy is still a very new package and does not have all the features in SunPy. In the above we can see that the time of the observation is not shown, and the coordinate axes are not labelled and they appear in degrees/minutes/arcseconds instead of just arcseconds. We can manually create a more complete plot: # Use WCS coordinates, but drop last axis (time) ax = plt . subplot ( projection = sji . wcs . dropaxis ( - 1 )) img = ax . imshow ( sji [ 0 ] . data , cmap = 'irissji2832' , vmin = 0 ) ax . coords [ 0 ] . set_major_formatter ( 's.s' ) ax . coords [ 1 ] . set_major_formatter ( 's.s' ) ax . grid ( color = 'w' , ls = ':' ) ax . set_xlabel ( \"Helioprojective Longitude (Solar-X) [arcsec]\" ) ax . set_ylabel ( \"Helioprojective Latitude (Solar-Y) [arcsec]\" ) ax . set_title ( \"IRIS SJI %.0f \u00c5 %s \" % ( sji . meta [ 'TWAVE1' ], sji . extra_coords [ 'TIME' ][ 'value' ][ 0 ])) plt . colorbar ( img , ax = ax ) plt . show () Now we have a plot that is much closer to that of SunPy map. What is different between IRIS and AIA images? The image above is different from the AIA images in many ways: We have only a small field-of-view and not the whole disk, but higher spatial resolution There is a vertical black line (the IRIS slit) The coordinate axes and grid are not always aligned with the image axes because IRIS can be rotated (rolled) for observations. In this case the roll is about 45\u00ba There is a white border around the image with a slight tilt. These are CCD pixels that are not exposed to solar light, and in some cases can also be padding for the full size of a raster. Using AIA for context \u00b6 We can use IRIS to zoom in on the small details, and AIA to get a global view. Let us look at an AIA image and see the region surrounding the IRIS field-of-view. We will use the first AIA 1700\u00c5 image we downloaded earlier in the AIA exercises, with a file name of aia_20140919_060030_1700_image_lev1.fits , that should be in ~/sunpy/data (if you don't have it, please run the SunPy exercise again). Please adjust the following to make sure it reflects the path in your computer: aia_file = '/Users/tiago/sunpy/data/aia_20140919_060030_1700_image_lev1.fits' tmp = sunpy . map . Map ( aia_file ) aia = aiaprep ( tmp ) # create a submap around the sunspots top_right = SkyCoord ( - 550 * u . arcsec , 180 * u . arcsec , frame = aia . coordinate_frame ) bottom_left = SkyCoord ( - 900 * u . arcsec , - 80. * u . arcsec , frame = aia . coordinate_frame ) aia_sub = aia . submap ( top_right , bottom_left ) aia_sub . plot () plt . show () This is what we saw earlier. Now let's plot the IRIS field of view on the AIA image using the information from the WCS coordinates. We will use the method pixel_to_world to convert from pixels to WCS coordinates, and then plot a polygon using the coordinates of the 4 corners of the IRIS image: aia_sub . plot () ax = plt . gca () dims = sji . data . shape _ , ypts , xpts = sji . pixel_to_world ( numpy . zeros ( 4 ) * u . pix , [ 0 , dims [ 1 ] - 1 , dims [ 1 ] - 1 , 0 ] * u . pix , [ 0 , 0 , dims [ 2 ] - 1 , dims [ 2 ] - 1 ] * u . pix ) iris_points = numpy . array ([ xpts . value , ypts . value , ]) . T r = Polygon ( iris_points , closed = True , edgecolor = 'b' , facecolor = 'none' , lw = 2 , transform = ax . get_transform ( 'world' )) ax . add_patch ( r ) plt . show () So now we have the blue square showing the region of the IRIS observations. If we compare with the IRIS image above, this seems right: we capture both sunspots, and one of them is close to the edge. To work with both IRIS and AIA data, it helps if the image axes are aligned, and for this we need to rotate one of them. We can either rotate AIA to the IRIS frame, or vice-versa. Generally, it is easier to rotate AIA to IRIS because IRIS images are higher resolution and the files contain a sequence of images. Let's do that, again using the WCS coordinates of both objects. First, we rotate the AIA map using the inverse rotation of the IRIS frame: aia_rot = aia . rotate ( rmatrix = numpy . matrix ( sji . wcs . wcs . pc [: - 1 , : - 1 ]) . I ) # Create submap on rotated image, with slightly smaller lower field of view top_right = SkyCoord ( - 610 * u . arcsec , 160 * u . arcsec , frame = aia_rot . coordinate_frame ) bottom_left = SkyCoord ( - 880 * u . arcsec , - 40. * u . arcsec , frame = aia_rot . coordinate_frame ) aia_rot_sub = aia_rot . submap ( top_right , bottom_left ) aia_rot_sub . plot () # add the same IRIS field-of-view: ax = plt . gca () r = Polygon ( iris_points , closed = True , edgecolor = 'b' , facecolor = 'none' , lw = 2 , transform = ax . get_transform ( 'world' )) ax . add_patch ( r ) plt . show () We can now see that the IRIS field-of-view appears as a straight square, because we rotated the view so the image axes of AIA and IRIS coincide. Here we show a submap of AIA to see a larger region around the IRIS observations. Can you make an AIA submap be the same field-of-view as IRIS? Above, we define two coordinates, top_right and bottom_left (from Skycoord , in arcsec). So to make an AIA submap be exactly the same field-of-view as IRIS, we just need to change top_right and bottom_left to be the limits of the IRIS image. We already have these IRIS coordinates when we plot the blue square, so we just need to find which ones are the bottom left and top right corners and put them on a SkyCoord object. In this case, it is: top_right = SkyCoord ( xpts [ 0 ], ypts [ 0 ], frame = aia_rot . coordinate_frame ) bottom_left = SkyCoord ( xpts [ - 2 ], ypts [ - 2 ], frame = aia_rot . coordinate_frame ) Putting everything together \u00b6 We have seen how to load an IRIS image, and how to plot its field-of-view on top of an AIA image. Now we are going to directly compare IRIS with AIA. First, we need to make sure we compare images taken at similar times, because the solar atmosphere evolves quickly. The AIA image above was taken on 2014-09-19 06:00:30. How do we find the IRIS image closest in time? The observing time for each IRIS image is saved under sji.extra_coords['TIME'] . Let us start by finding out the time of this observation. The time each frame was acquired is saved under sji.extra_coords['TIME'] , and the AIA observing time is saved in .meta [ ' date-obs ' ] : # convert AIA time from string to datetime aia_time = parse_time ( aia_rot_sub . meta [ 'date-obs' ]) iris_times = sji . extra_coords [ 'TIME' ][ 'value' ] # Now get the difference between AIA and IRIS times time_diff = aia_time - iris_times # and the index with the lowest difference time_index = numpy . argmin ( numpy . abs ( time_diff )) print ( \"AIA time: %s \\n IRIS time: %s \" % ( aia_time , iris_times [ time_index ])) AIA time: 2014-09-19 06:00:30.711610 IRIS time: 2014-09-19 06:00:58.670000 We see that the closest IRIS time is about 28 seconds after the AIA observation, which is ok. We can now plot the IRIS and AIA side by side: fig = plt . figure () ax1 = fig . add_subplot ( 1 , 2 , 1 , projection = aia_rot_sub ) aia_rot_sub . plot () r = Polygon ( iris_points , closed = True , edgecolor = 'b' , facecolor = 'none' , lw = 2 , transform = ax1 . get_transform ( 'world' )) ax1 . add_patch ( r ) ax2 = fig . add_subplot ( 1 , 2 , 2 , projection = sji . wcs . dropaxis ( - 1 )) img = ax2 . imshow ( sji [ time_index ] . data , cmap = 'irissji2832' , vmin = 0 ) ax2 . coords [ 0 ] . set_major_formatter ( 's.s' ) ax2 . coords [ 1 ] . set_major_formatter ( 's.s' ) ax2 . grid ( color = 'w' , ls = ':' ) ax2 . set_xlabel ( \"Helioprojective Longitude (Solar-X) [arcsec]\" ) ax2 . set_ylabel ( \"Helioprojective Latitude (Solar-Y) [arcsec]\" ) ax2 . set_title ( \"IRIS SJI %.0f \u00c5 %s \" % ( sji . meta [ 'TWAVE1' ], sji . extra_coords [ 'TIME' ][ 'value' ][ 0 ])) plt . show () Measuring spatial scales \u00b6 When analysing images, we often want to measure spatial scales in e.g. km. How do we convert from image pixels to km? And how to we measure image pixels? We have seen above that to convert from pixels to WCS coordinates we can make use of .pixel_to_world . For SunPy Map objects such as our AIA image, the output is a SkyCoord (we have only two dimensions): c = aia_rot_sub . pixel_to_world ( 0 * u . pix , 0 * u . pix ) c <SkyCoord (Helioprojective: obstime=2014-09-19 06:00:30.711610, rsun=696000000.0 m, observer=<HeliographicStonyhurst Coordinate (obstime=2014-09-19 06:00:30.711610): (lon, lat, radius) in (deg, deg, m) (0., 7.1342492, 1.50333097e+11)>): (Tx, Ty) in arcsec (-979.39734017, 62.42308006)> The solar X and Y coordinates in arcsec can be accessed by: c . Tx , c . Ty (<Longitude -979.39734017 arcsec>, <Latitude 62.42308006 arcsec>) For IRISMapCube objects, the data have 3 dimensions (time being the first), and we must specify all: sji . pixel_to_world ( 0 * u . pix , 0 * u . pix , 0 * u . pix ) [<Quantity 2506.4372 s>, <Quantity 0.01548156 deg>, <Quantity -0.23177934 deg>] The output is in different Quantity objects, the first being the time since the start of the IRIS observation, followed by solar X and Y in degrees. Now let us assume that in the IRIS image, we want to calculate the distance between the sunspots. With coordinates, we can overplot lines on top of the images (as we did previously with the IRIS field of view on AIA). Let us plot the IRIS image and plot the approximate coordinates between the centres of the sunspot (these were obtained by experimenting): ax = plt . subplot ( projection = sji . wcs . dropaxis ( - 1 )) ax . imshow ( sji [ 0 ] . data , cmap = 'irissji2832' , vmin = 0 ) ax . coords [ 0 ] . set_major_formatter ( 's.s' ) ax . coords [ 1 ] . set_major_formatter ( 's.s' ) ax . grid ( color = 'w' , ls = ':' ) # approximate (x, y) coordinates of sunspots in arcsec sunspot1 = [ - 720 , 97 ] * u . arcsec sunspot2 = [ - 716 , 11 ] * u . arcsec # Must convert from arcsec to degrees because WCSAxes works always in degrees sunspot_x = u . Quantity ([ sunspot1 [ 0 ], sunspot2 [ 0 ]]) . to ( u . deg ) sunspot_y = u . Quantity ([ sunspot1 [ 1 ], sunspot2 [ 1 ]]) . to ( u . deg ) # use get_transform('world') to plot in coordinate space ax . plot ( sunspots_x , sunspots_y , 'bo-' , transform = ax . get_transform ( 'world' ), ms = 10 ) plt . show () Now that we have the coordinates, the distance between the sunspots is simply the euclidian distance: d = \\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2} d = \\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2} We can use numpy.linalg.norm to avoid having to type all those points by hand, and we get the distance in arcsec: dist = numpy . linalg . norm ( sunspot1 - sunspot2 ) * u . arcsec dist 86.092973 \\; \\mathrm{{}^{\\prime\\prime}} 86.092973 \\; \\mathrm{{}^{\\prime\\prime}} In any case, a question remains: how to convert from coordinates (deg, arcsec) to distance in km? Angular vs linear distance So far we are working with angular distances and not linear distances. When the angular size of an object is very small (less than 1\u00ba, as most astronomical objects), we can use the small angle approximation and relate the angular to linear distance: d = \\alpha D d = \\alpha D , where \\alpha \\alpha is the angular distance (in radians) and D D is the distance to the object (in our case, the Sun). When is Earth closer to the Sun? The distance between Earth and the Sun varies with time, because Earth's orbit is not perfectly circular. The point when Earth is closest to the Sun is called periapsis and takes place approximately on January 3. The point when Earth is farthest from the Sun is called apoapsis and takes place approximately on July 3. The distance between the Sun and Earth is 1 au, or 149.597 Gm, but this is the mean distance between perihelion and aphelion. The exact distance will depend on the time of our observations. Fortunately, SunPy has utility functions that we can use to calculate this: from sunpy.coordinates import frames # time of first IRIS image obs_date = sji . extra_coords [ 'TIME' ][ 'value' ][ 0 ] # get 1\" interval at disk-centre between in cartesian coordinates a1 = SkyCoord ( 0 * u . arcsec , 0 * u . arcsec , frame = 'helioprojective' , obstime = obs_date ) . transform_to ( 'heliocentric' ) . x a2 = SkyCoord ( 1 * u . arcsec , 0 * u . arcsec , frame = 'helioprojective' , obstime = obs_date ) . transform_to ( 'heliocentric' ) . x asec_to_Mm = ( a2 - a1 ) . to ( u . Mm ) asec_to_Mm 0.72526922 \\; \\mathrm{Mm} 0.72526922 \\; \\mathrm{Mm} So we see that in this date, 1 {}^{\\prime\\prime} {}^{\\prime\\prime} is about 725.26922 km. We can use this to convert the distance between the sunspots and get the final result in Mm: dist_Mm = dist . value * asec_to_Mm dist_Mm 62.440583 \\; \\mathrm{Mm} 62.440583 \\; \\mathrm{Mm}","title":"IRIS and AIA"},{"location":"IRIS/#iris-and-aia","text":"To work with IRIS data in Python we will make use of the IRISPy package. IRISPy is an affiliated package of SunPy.","title":"IRIS and AIA"},{"location":"IRIS/#initialisation","text":"% matplotlib inline from matplotlib import pyplot as plt from matplotlib.patches import Polygon import numpy from irispy.sji import read_iris_sji_level2_fits import sunpy.map from sunpy.instr.aia import aiaprep from sunpy.time import parse_time from astropy.coordinates import SkyCoord from astropy import units as u # To make a larger figure plt . rcParams [ 'figure.figsize' ] = [ 10 , 9 ] import warnings warnings . filterwarnings ( \"ignore\" )","title":"Initialisation"},{"location":"IRIS/#working-with-iris-sji-files","text":"Let us start by loading the IRIS dataset that was taken at a similar time to the AIA images we worked on earlier. IRIS has both a spectrograph and an imager, but here we'll work only with the imager (SJI = Slit-Jaw Image). These images show the position of the spectrograph slit with respect to the solar image. The slit is the central, vertical dark line in the images. To read IRIS SJI files, we'll make use of the read_iris_sji_level2_fits from IRISPy : sji = read_iris_sji_level2_fits ( \"iris_l2_20140919_051712_3860608353_SJI_2832_t000.fits\" ) sji INFO : uncertainty should have attribute uncertainty_type . [ astropy . nddata . nddata ] IRISMapCube --------- Observatory : IRIS Instrument : SJI Bandpass : 2832.0 Obs . Start : 2014 - 09 - 19 T05 : 17 : 12.610000 Obs . End : 2014 - 09 - 19 T07 : 14 : 54.895000 Instance Start : 2014 - 09 - 19 T05 : 17 : 31.110000 Instance End : 2014 - 09 - 19 T07 : 13 : 24.610000 Total Frames in Obs .: 65 IRIS Obs . id : 3860608353 IRIS Obs . Description : Large sit - and - stare 0.3 x120 1 s C II Mg II h / k Mg II w s Deep x Cube dimensions : [ 65 . 387 . 364 .] pix Axis Types : ( None , 'custom:pos.helioprojective.lat' , 'custom:pos.helioprojective.lon' ) This loads the data into an IRISMapCube object. Unlike AIA, an IRIS SJI file contains many images. In the summary above, we can see that this sequence on 2014-09-19 goes from 05:17:31 to 07:13:24 and contains 65 images. Each image has dimensions of (nx, ny) = (387, 364). Like Map in SunPy, IRISMapCube contains additional metadata, including the coordinates of the observation. It also has a .plot () method, that allows a quick plotting of images: sji [ 0 ] . plot () plt . show () Here, we are plotting the first image in the sequence. It is also possible to simply call sji.plot() , which will return an animator instance that can play a movie of all images when an interactive matplotlib backend is used (here we are using inline , which works better in the browser, but is not interactive). The plot does not look as complete as sunpy.map.Map.plot() because IRISPy is still a very new package and does not have all the features in SunPy. In the above we can see that the time of the observation is not shown, and the coordinate axes are not labelled and they appear in degrees/minutes/arcseconds instead of just arcseconds. We can manually create a more complete plot: # Use WCS coordinates, but drop last axis (time) ax = plt . subplot ( projection = sji . wcs . dropaxis ( - 1 )) img = ax . imshow ( sji [ 0 ] . data , cmap = 'irissji2832' , vmin = 0 ) ax . coords [ 0 ] . set_major_formatter ( 's.s' ) ax . coords [ 1 ] . set_major_formatter ( 's.s' ) ax . grid ( color = 'w' , ls = ':' ) ax . set_xlabel ( \"Helioprojective Longitude (Solar-X) [arcsec]\" ) ax . set_ylabel ( \"Helioprojective Latitude (Solar-Y) [arcsec]\" ) ax . set_title ( \"IRIS SJI %.0f \u00c5 %s \" % ( sji . meta [ 'TWAVE1' ], sji . extra_coords [ 'TIME' ][ 'value' ][ 0 ])) plt . colorbar ( img , ax = ax ) plt . show () Now we have a plot that is much closer to that of SunPy map. What is different between IRIS and AIA images? The image above is different from the AIA images in many ways: We have only a small field-of-view and not the whole disk, but higher spatial resolution There is a vertical black line (the IRIS slit) The coordinate axes and grid are not always aligned with the image axes because IRIS can be rotated (rolled) for observations. In this case the roll is about 45\u00ba There is a white border around the image with a slight tilt. These are CCD pixels that are not exposed to solar light, and in some cases can also be padding for the full size of a raster.","title":"Working with IRIS SJI files"},{"location":"IRIS/#using-aia-for-context","text":"We can use IRIS to zoom in on the small details, and AIA to get a global view. Let us look at an AIA image and see the region surrounding the IRIS field-of-view. We will use the first AIA 1700\u00c5 image we downloaded earlier in the AIA exercises, with a file name of aia_20140919_060030_1700_image_lev1.fits , that should be in ~/sunpy/data (if you don't have it, please run the SunPy exercise again). Please adjust the following to make sure it reflects the path in your computer: aia_file = '/Users/tiago/sunpy/data/aia_20140919_060030_1700_image_lev1.fits' tmp = sunpy . map . Map ( aia_file ) aia = aiaprep ( tmp ) # create a submap around the sunspots top_right = SkyCoord ( - 550 * u . arcsec , 180 * u . arcsec , frame = aia . coordinate_frame ) bottom_left = SkyCoord ( - 900 * u . arcsec , - 80. * u . arcsec , frame = aia . coordinate_frame ) aia_sub = aia . submap ( top_right , bottom_left ) aia_sub . plot () plt . show () This is what we saw earlier. Now let's plot the IRIS field of view on the AIA image using the information from the WCS coordinates. We will use the method pixel_to_world to convert from pixels to WCS coordinates, and then plot a polygon using the coordinates of the 4 corners of the IRIS image: aia_sub . plot () ax = plt . gca () dims = sji . data . shape _ , ypts , xpts = sji . pixel_to_world ( numpy . zeros ( 4 ) * u . pix , [ 0 , dims [ 1 ] - 1 , dims [ 1 ] - 1 , 0 ] * u . pix , [ 0 , 0 , dims [ 2 ] - 1 , dims [ 2 ] - 1 ] * u . pix ) iris_points = numpy . array ([ xpts . value , ypts . value , ]) . T r = Polygon ( iris_points , closed = True , edgecolor = 'b' , facecolor = 'none' , lw = 2 , transform = ax . get_transform ( 'world' )) ax . add_patch ( r ) plt . show () So now we have the blue square showing the region of the IRIS observations. If we compare with the IRIS image above, this seems right: we capture both sunspots, and one of them is close to the edge. To work with both IRIS and AIA data, it helps if the image axes are aligned, and for this we need to rotate one of them. We can either rotate AIA to the IRIS frame, or vice-versa. Generally, it is easier to rotate AIA to IRIS because IRIS images are higher resolution and the files contain a sequence of images. Let's do that, again using the WCS coordinates of both objects. First, we rotate the AIA map using the inverse rotation of the IRIS frame: aia_rot = aia . rotate ( rmatrix = numpy . matrix ( sji . wcs . wcs . pc [: - 1 , : - 1 ]) . I ) # Create submap on rotated image, with slightly smaller lower field of view top_right = SkyCoord ( - 610 * u . arcsec , 160 * u . arcsec , frame = aia_rot . coordinate_frame ) bottom_left = SkyCoord ( - 880 * u . arcsec , - 40. * u . arcsec , frame = aia_rot . coordinate_frame ) aia_rot_sub = aia_rot . submap ( top_right , bottom_left ) aia_rot_sub . plot () # add the same IRIS field-of-view: ax = plt . gca () r = Polygon ( iris_points , closed = True , edgecolor = 'b' , facecolor = 'none' , lw = 2 , transform = ax . get_transform ( 'world' )) ax . add_patch ( r ) plt . show () We can now see that the IRIS field-of-view appears as a straight square, because we rotated the view so the image axes of AIA and IRIS coincide. Here we show a submap of AIA to see a larger region around the IRIS observations. Can you make an AIA submap be the same field-of-view as IRIS? Above, we define two coordinates, top_right and bottom_left (from Skycoord , in arcsec). So to make an AIA submap be exactly the same field-of-view as IRIS, we just need to change top_right and bottom_left to be the limits of the IRIS image. We already have these IRIS coordinates when we plot the blue square, so we just need to find which ones are the bottom left and top right corners and put them on a SkyCoord object. In this case, it is: top_right = SkyCoord ( xpts [ 0 ], ypts [ 0 ], frame = aia_rot . coordinate_frame ) bottom_left = SkyCoord ( xpts [ - 2 ], ypts [ - 2 ], frame = aia_rot . coordinate_frame )","title":"Using AIA for context"},{"location":"IRIS/#putting-everything-together","text":"We have seen how to load an IRIS image, and how to plot its field-of-view on top of an AIA image. Now we are going to directly compare IRIS with AIA. First, we need to make sure we compare images taken at similar times, because the solar atmosphere evolves quickly. The AIA image above was taken on 2014-09-19 06:00:30. How do we find the IRIS image closest in time? The observing time for each IRIS image is saved under sji.extra_coords['TIME'] . Let us start by finding out the time of this observation. The time each frame was acquired is saved under sji.extra_coords['TIME'] , and the AIA observing time is saved in .meta [ ' date-obs ' ] : # convert AIA time from string to datetime aia_time = parse_time ( aia_rot_sub . meta [ 'date-obs' ]) iris_times = sji . extra_coords [ 'TIME' ][ 'value' ] # Now get the difference between AIA and IRIS times time_diff = aia_time - iris_times # and the index with the lowest difference time_index = numpy . argmin ( numpy . abs ( time_diff )) print ( \"AIA time: %s \\n IRIS time: %s \" % ( aia_time , iris_times [ time_index ])) AIA time: 2014-09-19 06:00:30.711610 IRIS time: 2014-09-19 06:00:58.670000 We see that the closest IRIS time is about 28 seconds after the AIA observation, which is ok. We can now plot the IRIS and AIA side by side: fig = plt . figure () ax1 = fig . add_subplot ( 1 , 2 , 1 , projection = aia_rot_sub ) aia_rot_sub . plot () r = Polygon ( iris_points , closed = True , edgecolor = 'b' , facecolor = 'none' , lw = 2 , transform = ax1 . get_transform ( 'world' )) ax1 . add_patch ( r ) ax2 = fig . add_subplot ( 1 , 2 , 2 , projection = sji . wcs . dropaxis ( - 1 )) img = ax2 . imshow ( sji [ time_index ] . data , cmap = 'irissji2832' , vmin = 0 ) ax2 . coords [ 0 ] . set_major_formatter ( 's.s' ) ax2 . coords [ 1 ] . set_major_formatter ( 's.s' ) ax2 . grid ( color = 'w' , ls = ':' ) ax2 . set_xlabel ( \"Helioprojective Longitude (Solar-X) [arcsec]\" ) ax2 . set_ylabel ( \"Helioprojective Latitude (Solar-Y) [arcsec]\" ) ax2 . set_title ( \"IRIS SJI %.0f \u00c5 %s \" % ( sji . meta [ 'TWAVE1' ], sji . extra_coords [ 'TIME' ][ 'value' ][ 0 ])) plt . show ()","title":"Putting everything together"},{"location":"IRIS/#measuring-spatial-scales","text":"When analysing images, we often want to measure spatial scales in e.g. km. How do we convert from image pixels to km? And how to we measure image pixels? We have seen above that to convert from pixels to WCS coordinates we can make use of .pixel_to_world . For SunPy Map objects such as our AIA image, the output is a SkyCoord (we have only two dimensions): c = aia_rot_sub . pixel_to_world ( 0 * u . pix , 0 * u . pix ) c <SkyCoord (Helioprojective: obstime=2014-09-19 06:00:30.711610, rsun=696000000.0 m, observer=<HeliographicStonyhurst Coordinate (obstime=2014-09-19 06:00:30.711610): (lon, lat, radius) in (deg, deg, m) (0., 7.1342492, 1.50333097e+11)>): (Tx, Ty) in arcsec (-979.39734017, 62.42308006)> The solar X and Y coordinates in arcsec can be accessed by: c . Tx , c . Ty (<Longitude -979.39734017 arcsec>, <Latitude 62.42308006 arcsec>) For IRISMapCube objects, the data have 3 dimensions (time being the first), and we must specify all: sji . pixel_to_world ( 0 * u . pix , 0 * u . pix , 0 * u . pix ) [<Quantity 2506.4372 s>, <Quantity 0.01548156 deg>, <Quantity -0.23177934 deg>] The output is in different Quantity objects, the first being the time since the start of the IRIS observation, followed by solar X and Y in degrees. Now let us assume that in the IRIS image, we want to calculate the distance between the sunspots. With coordinates, we can overplot lines on top of the images (as we did previously with the IRIS field of view on AIA). Let us plot the IRIS image and plot the approximate coordinates between the centres of the sunspot (these were obtained by experimenting): ax = plt . subplot ( projection = sji . wcs . dropaxis ( - 1 )) ax . imshow ( sji [ 0 ] . data , cmap = 'irissji2832' , vmin = 0 ) ax . coords [ 0 ] . set_major_formatter ( 's.s' ) ax . coords [ 1 ] . set_major_formatter ( 's.s' ) ax . grid ( color = 'w' , ls = ':' ) # approximate (x, y) coordinates of sunspots in arcsec sunspot1 = [ - 720 , 97 ] * u . arcsec sunspot2 = [ - 716 , 11 ] * u . arcsec # Must convert from arcsec to degrees because WCSAxes works always in degrees sunspot_x = u . Quantity ([ sunspot1 [ 0 ], sunspot2 [ 0 ]]) . to ( u . deg ) sunspot_y = u . Quantity ([ sunspot1 [ 1 ], sunspot2 [ 1 ]]) . to ( u . deg ) # use get_transform('world') to plot in coordinate space ax . plot ( sunspots_x , sunspots_y , 'bo-' , transform = ax . get_transform ( 'world' ), ms = 10 ) plt . show () Now that we have the coordinates, the distance between the sunspots is simply the euclidian distance: d = \\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2} d = \\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2} We can use numpy.linalg.norm to avoid having to type all those points by hand, and we get the distance in arcsec: dist = numpy . linalg . norm ( sunspot1 - sunspot2 ) * u . arcsec dist 86.092973 \\; \\mathrm{{}^{\\prime\\prime}} 86.092973 \\; \\mathrm{{}^{\\prime\\prime}} In any case, a question remains: how to convert from coordinates (deg, arcsec) to distance in km? Angular vs linear distance So far we are working with angular distances and not linear distances. When the angular size of an object is very small (less than 1\u00ba, as most astronomical objects), we can use the small angle approximation and relate the angular to linear distance: d = \\alpha D d = \\alpha D , where \\alpha \\alpha is the angular distance (in radians) and D D is the distance to the object (in our case, the Sun). When is Earth closer to the Sun? The distance between Earth and the Sun varies with time, because Earth's orbit is not perfectly circular. The point when Earth is closest to the Sun is called periapsis and takes place approximately on January 3. The point when Earth is farthest from the Sun is called apoapsis and takes place approximately on July 3. The distance between the Sun and Earth is 1 au, or 149.597 Gm, but this is the mean distance between perihelion and aphelion. The exact distance will depend on the time of our observations. Fortunately, SunPy has utility functions that we can use to calculate this: from sunpy.coordinates import frames # time of first IRIS image obs_date = sji . extra_coords [ 'TIME' ][ 'value' ][ 0 ] # get 1\" interval at disk-centre between in cartesian coordinates a1 = SkyCoord ( 0 * u . arcsec , 0 * u . arcsec , frame = 'helioprojective' , obstime = obs_date ) . transform_to ( 'heliocentric' ) . x a2 = SkyCoord ( 1 * u . arcsec , 0 * u . arcsec , frame = 'helioprojective' , obstime = obs_date ) . transform_to ( 'heliocentric' ) . x asec_to_Mm = ( a2 - a1 ) . to ( u . Mm ) asec_to_Mm 0.72526922 \\; \\mathrm{Mm} 0.72526922 \\; \\mathrm{Mm} So we see that in this date, 1 {}^{\\prime\\prime} {}^{\\prime\\prime} is about 725.26922 km. We can use this to convert the distance between the sunspots and get the final result in Mm: dist_Mm = dist . value * asec_to_Mm dist_Mm 62.440583 \\; \\mathrm{Mm} 62.440583 \\; \\mathrm{Mm}","title":"Measuring spatial scales"},{"location":"assignment/","text":"Introduction \u00b6 Your assignment will be to shed some light on a mysterious event observed by IRIS. At around 09:00 on 2015-03-19, IRIS observed an unusual event at the solar limb. A swirling mass of gas was hovering above the solar surface, and it erupted at some point. You can read a short description about this event on an IRIS movie of the day . Unfortunately, only one IRIS SJI camera was used, and the field of view covers very little of the solar disk, so we have no context information. Your task will be to use AIA and IRIS to uncover what was going on. You should have downloaded the IRIS SJI 1400 file for this event. You can also have a look at the IRIS event page for more information about the observation and some quicklook movies. This FITS file contains 1920 images, and therefore the quicklook movies are very large (see the IRIS movie of the day event for a smaller movie). For the assignment we are interested in the images around the eruption, and will not use most of the other images. An additional complication of this IRIS dataset is that the images cover mostly the region outside the solar limb, where there is very little light. Also, 140 nm images have a lot more contrast than the 283.2 nm images we looked at before. This makes it hard to actually see the material outside the solar limb with the default (linear) scaling. For example, plotting image index 700: % matplotlib inline from matplotlib import pyplot as plt plt . rcParams [ 'figure.figsize' ] = [ 10 , 9 ] from irispy.sji import read_iris_sji_level2_fits import warnings warnings . filterwarnings ( \"ignore\" ) sji = read_iris_sji_level2_fits ( \"iris_l2_20150319_090911_3860359580_SJI_1330_t000.fits\" ) plt . figure () ax = plt . subplot ( projection = sji . wcs . dropaxis ( - 1 )) ax . coords [ 0 ] . set_major_formatter ( 's.s' ) ax . coords [ 1 ] . set_major_formatter ( 's.s' ) ax . grid ( color = 'w' , ls = ':' ) ax . set_xlabel ( \"Helioprojective Longitude (Solar-X) [arcsec]\" ) ax . set_ylabel ( \"Helioprojective Latitude (Solar-Y) [arcsec]\" ) ax . set_title ( \"IRIS SJI %.0f \u00c5 %s \" % ( sji . meta [ 'TWAVE1' ], sji . extra_coords [ 'TIME' ][ 'value' ][ 1000 ])) img = ax . imshow ( sji [ 700 ] . data , cmap = 'irissji1330' , vmin = 0 , vmax = 1500 ) plt . show () The off-limb image is difficult to see. To make it more visible, we can saturate the image more (e.g. set vmax=100 in the imshow call above), but then the brighter parts become very saturated and it is difficult to see any structure. Another option is to use non-linear scaling. Log scale is an option (e.g. use np.log10(sji[700].data) in imshow above), or we can use a Gamma correction , which is simply taking the image to an exponent. In this case we get good results with a Gamma of 0.3: plt . figure () ax = plt . subplot ( projection = sji . wcs . dropaxis ( - 1 )) ax . coords [ 0 ] . set_major_formatter ( 's.s' ) ax . coords [ 1 ] . set_major_formatter ( 's.s' ) ax . grid ( color = 'w' , ls = ':' ) ax . set_xlabel ( \"Helioprojective Longitude (Solar-X) [arcsec]\" ) ax . set_ylabel ( \"Helioprojective Latitude (Solar-Y) [arcsec]\" ) ax . set_title ( \"IRIS SJI %.0f \u00c5 %s \" % ( sji . meta [ 'TWAVE1' ], sji . extra_coords [ 'TIME' ][ 'value' ][ 700 ])) # trick with sign and abs to avoid negative numbers before taking power # (these would give NaNs because powers are calculated with logarithms) tmp = np . sign ( sji [ 700 ] . data ) * np . abs ( sji [ 700 ] . data ) ** 0.3 img = ax . imshow ( tmp , cmap = 'irissji1330' , vmin = 0.5 , vmax = 1000 ** 0.3 ) plt . show () Now we can see more details in the image. This is what is done for the quicklook movies. We use a trick above with np.sign and np.abs to ensure we are taking the power of a positive number. Otherwise, we could end up with floating point errors because logarithms are used internally, and we would see white dots in the image above. IRIS scans In this dataset, IRIS is scanning, meaning that the field of view is moving between several positions. This image movement is taken into account when they are saved into the level 2 FITS files, and extra padding (negative or zero numbers) is included on the sides of the image array to account for the full motion of the camera. This way, the Sun stays at a fixed position in the image, while the exposed area moves. This can be seen clearly in the quicklook movies. Questions \u00b6 When did the eruption take place? \u00b6 At what (approximate) time did the eruption take place, or was brightest? What index does this time correspond to in the 1400 images? Make a plot of the IRIS image at this time. Did you notice anything odd in the disk part of the 1400 images before or during the eruption? Hint Look at the quicklook movies to find the approximate time of the eruption. Remember that SJI observing times are saved in sji.extra_coords['TIME']['value'] . Enter your answer here # Enter code to support your answer here What does AIA tell you about the eruption? \u00b6 Download one AIA 171 image at approximately the same time as the IRIS eruption. Calibrate, rotate it to the IRIS rotation and make a plot of this image for a region about twice as large as the IRIS field. Overplot the IRIS SJI field-of-view. Do you see any CCD blooming or diffraction pattern around the erupting material in 171? Download an AIA 94 image observed on 2015-03-19T12:48:13 . Make a side-by-side comparison with an IRIS image taken at the same time (again, will be helpful to rotate AIA to match IRIS, and to overplot the IRIS field-of-view). Do you find any similar features? What does this tell you about the formation temperature of some features in the IRIS image? Hint To make the plots you can copy paste much of the example code (adjusted to your needs!). For question 3., remember that AIA 94 \u00c5 images are formed at about 6 million K, while IRIS 1300 \u00c5 images have contributions from C II (~15,000 K) and Fe XXI (about 10 million K). Enter your answer here # Enter code for your answer here Feel free to insert more text and code cells, if you want to explain in between code parts. How fast are things moving? \u00b6 Measure the speed (in km/s) in the IRIS images of the blob of plasma whose tip is at (x,y)=(936\u2033,-366\u2033.6), at 2015-03-19 09:34:20.95 . You only need to measure a few frames to get an approximate speed. Choose a moving blob of fast-moving plasma, at 2015-03-19 12:33:21.63 or after (ie, after the eruption) and measure its speed in km/s. Make plots showing your chosen blob in the beginning and at the end of your measuring interval. Hint To measure speeds, you need to measure the position of a feature in different images, then divide the displacement by the time difference. To minimise uncertainties, you can do this for 3-5 images and take the mean speed. Enter your answer here # Enter code for your answer here Feel free to insert more text and code cells, if you want to explain in between code parts. Format and assessment criteria \u00b6 The assignment should be handed in as a Jupyter notebook, which will be your report for this lab. Please use the template , which contains the questions and includes code cells where you should enter code that does what is required to answer the questions. You are free to modify the notebook in any way you seem fit, but please keep the original questions. Answering questions will require not just code, but also written text to justify your choices and answer the question. The assignment will be marked according to the following criteria: All code cells must run (when executed sequentially) and perform what is expected, without giving any errors (warnings are ok!). The code should be concise and not require excessive computations/downloads. Extra points will be given to clean, readable code while messy or redundant code will be penalised. Explanations for the code should be written in markdown (text) cells. The language and length of the replies will also be marked. It should be clean and concise. Tips and suggestions \u00b6 Data exploration vs. presentation It is important to make a distinction between your final report (presentation) and the steps you took to find out the answer (exploration). It is probably a good idea to create a new notebook for experiments, and only fill in the report notebook when you have a working answer. Your exploration steps will be by definition less polished and prone to trial and error (which is normal!). Matplotlib interactive mode So far we have started all notebooks by using %matplotlib inline , which will display the figures as inline images in the notebook. This is the option you should use for your final report. However, for exploring it can be convenient to use an interactive display, which lets you interact with the plot and get coordinates for the mouse position. To use an interactive display, you can use instead %matplotlib widget (displays an interactive figure in the browser), or %matplotlib qt (displays an external window, but requires the Qt backend). When using an interactive display with IRISPy, doing sji.plot() will have a play/pause button that lets you watch the image sequence as a movie. File downloads Keep an eye your file downloads (that you get through Fido ), and make sure the final report includes all steps necessary to download the files you really need to answer the questions.","title":"Assignment"},{"location":"assignment/#introduction","text":"Your assignment will be to shed some light on a mysterious event observed by IRIS. At around 09:00 on 2015-03-19, IRIS observed an unusual event at the solar limb. A swirling mass of gas was hovering above the solar surface, and it erupted at some point. You can read a short description about this event on an IRIS movie of the day . Unfortunately, only one IRIS SJI camera was used, and the field of view covers very little of the solar disk, so we have no context information. Your task will be to use AIA and IRIS to uncover what was going on. You should have downloaded the IRIS SJI 1400 file for this event. You can also have a look at the IRIS event page for more information about the observation and some quicklook movies. This FITS file contains 1920 images, and therefore the quicklook movies are very large (see the IRIS movie of the day event for a smaller movie). For the assignment we are interested in the images around the eruption, and will not use most of the other images. An additional complication of this IRIS dataset is that the images cover mostly the region outside the solar limb, where there is very little light. Also, 140 nm images have a lot more contrast than the 283.2 nm images we looked at before. This makes it hard to actually see the material outside the solar limb with the default (linear) scaling. For example, plotting image index 700: % matplotlib inline from matplotlib import pyplot as plt plt . rcParams [ 'figure.figsize' ] = [ 10 , 9 ] from irispy.sji import read_iris_sji_level2_fits import warnings warnings . filterwarnings ( \"ignore\" ) sji = read_iris_sji_level2_fits ( \"iris_l2_20150319_090911_3860359580_SJI_1330_t000.fits\" ) plt . figure () ax = plt . subplot ( projection = sji . wcs . dropaxis ( - 1 )) ax . coords [ 0 ] . set_major_formatter ( 's.s' ) ax . coords [ 1 ] . set_major_formatter ( 's.s' ) ax . grid ( color = 'w' , ls = ':' ) ax . set_xlabel ( \"Helioprojective Longitude (Solar-X) [arcsec]\" ) ax . set_ylabel ( \"Helioprojective Latitude (Solar-Y) [arcsec]\" ) ax . set_title ( \"IRIS SJI %.0f \u00c5 %s \" % ( sji . meta [ 'TWAVE1' ], sji . extra_coords [ 'TIME' ][ 'value' ][ 1000 ])) img = ax . imshow ( sji [ 700 ] . data , cmap = 'irissji1330' , vmin = 0 , vmax = 1500 ) plt . show () The off-limb image is difficult to see. To make it more visible, we can saturate the image more (e.g. set vmax=100 in the imshow call above), but then the brighter parts become very saturated and it is difficult to see any structure. Another option is to use non-linear scaling. Log scale is an option (e.g. use np.log10(sji[700].data) in imshow above), or we can use a Gamma correction , which is simply taking the image to an exponent. In this case we get good results with a Gamma of 0.3: plt . figure () ax = plt . subplot ( projection = sji . wcs . dropaxis ( - 1 )) ax . coords [ 0 ] . set_major_formatter ( 's.s' ) ax . coords [ 1 ] . set_major_formatter ( 's.s' ) ax . grid ( color = 'w' , ls = ':' ) ax . set_xlabel ( \"Helioprojective Longitude (Solar-X) [arcsec]\" ) ax . set_ylabel ( \"Helioprojective Latitude (Solar-Y) [arcsec]\" ) ax . set_title ( \"IRIS SJI %.0f \u00c5 %s \" % ( sji . meta [ 'TWAVE1' ], sji . extra_coords [ 'TIME' ][ 'value' ][ 700 ])) # trick with sign and abs to avoid negative numbers before taking power # (these would give NaNs because powers are calculated with logarithms) tmp = np . sign ( sji [ 700 ] . data ) * np . abs ( sji [ 700 ] . data ) ** 0.3 img = ax . imshow ( tmp , cmap = 'irissji1330' , vmin = 0.5 , vmax = 1000 ** 0.3 ) plt . show () Now we can see more details in the image. This is what is done for the quicklook movies. We use a trick above with np.sign and np.abs to ensure we are taking the power of a positive number. Otherwise, we could end up with floating point errors because logarithms are used internally, and we would see white dots in the image above. IRIS scans In this dataset, IRIS is scanning, meaning that the field of view is moving between several positions. This image movement is taken into account when they are saved into the level 2 FITS files, and extra padding (negative or zero numbers) is included on the sides of the image array to account for the full motion of the camera. This way, the Sun stays at a fixed position in the image, while the exposed area moves. This can be seen clearly in the quicklook movies.","title":"Introduction"},{"location":"assignment/#questions","text":"","title":"Questions"},{"location":"assignment/#when-did-the-eruption-take-place","text":"At what (approximate) time did the eruption take place, or was brightest? What index does this time correspond to in the 1400 images? Make a plot of the IRIS image at this time. Did you notice anything odd in the disk part of the 1400 images before or during the eruption? Hint Look at the quicklook movies to find the approximate time of the eruption. Remember that SJI observing times are saved in sji.extra_coords['TIME']['value'] . Enter your answer here # Enter code to support your answer here","title":"When did the eruption take place?"},{"location":"assignment/#what-does-aia-tell-you-about-the-eruption","text":"Download one AIA 171 image at approximately the same time as the IRIS eruption. Calibrate, rotate it to the IRIS rotation and make a plot of this image for a region about twice as large as the IRIS field. Overplot the IRIS SJI field-of-view. Do you see any CCD blooming or diffraction pattern around the erupting material in 171? Download an AIA 94 image observed on 2015-03-19T12:48:13 . Make a side-by-side comparison with an IRIS image taken at the same time (again, will be helpful to rotate AIA to match IRIS, and to overplot the IRIS field-of-view). Do you find any similar features? What does this tell you about the formation temperature of some features in the IRIS image? Hint To make the plots you can copy paste much of the example code (adjusted to your needs!). For question 3., remember that AIA 94 \u00c5 images are formed at about 6 million K, while IRIS 1300 \u00c5 images have contributions from C II (~15,000 K) and Fe XXI (about 10 million K). Enter your answer here # Enter code for your answer here Feel free to insert more text and code cells, if you want to explain in between code parts.","title":"What does AIA tell you about the eruption?"},{"location":"assignment/#how-fast-are-things-moving","text":"Measure the speed (in km/s) in the IRIS images of the blob of plasma whose tip is at (x,y)=(936\u2033,-366\u2033.6), at 2015-03-19 09:34:20.95 . You only need to measure a few frames to get an approximate speed. Choose a moving blob of fast-moving plasma, at 2015-03-19 12:33:21.63 or after (ie, after the eruption) and measure its speed in km/s. Make plots showing your chosen blob in the beginning and at the end of your measuring interval. Hint To measure speeds, you need to measure the position of a feature in different images, then divide the displacement by the time difference. To minimise uncertainties, you can do this for 3-5 images and take the mean speed. Enter your answer here # Enter code for your answer here Feel free to insert more text and code cells, if you want to explain in between code parts.","title":"How fast are things moving?"},{"location":"assignment/#format-and-assessment-criteria","text":"The assignment should be handed in as a Jupyter notebook, which will be your report for this lab. Please use the template , which contains the questions and includes code cells where you should enter code that does what is required to answer the questions. You are free to modify the notebook in any way you seem fit, but please keep the original questions. Answering questions will require not just code, but also written text to justify your choices and answer the question. The assignment will be marked according to the following criteria: All code cells must run (when executed sequentially) and perform what is expected, without giving any errors (warnings are ok!). The code should be concise and not require excessive computations/downloads. Extra points will be given to clean, readable code while messy or redundant code will be penalised. Explanations for the code should be written in markdown (text) cells. The language and length of the replies will also be marked. It should be clean and concise.","title":"Format and assessment criteria"},{"location":"assignment/#tips-and-suggestions","text":"Data exploration vs. presentation It is important to make a distinction between your final report (presentation) and the steps you took to find out the answer (exploration). It is probably a good idea to create a new notebook for experiments, and only fill in the report notebook when you have a working answer. Your exploration steps will be by definition less polished and prone to trial and error (which is normal!). Matplotlib interactive mode So far we have started all notebooks by using %matplotlib inline , which will display the figures as inline images in the notebook. This is the option you should use for your final report. However, for exploring it can be convenient to use an interactive display, which lets you interact with the plot and get coordinates for the mouse position. To use an interactive display, you can use instead %matplotlib widget (displays an interactive figure in the browser), or %matplotlib qt (displays an external window, but requires the Qt backend). When using an interactive display with IRISPy, doing sji.plot() will have a play/pause button that lets you watch the image sequence as a movie. File downloads Keep an eye your file downloads (that you get through Fido ), and make sure the final report includes all steps necessary to download the files you really need to answer the questions.","title":"Tips and suggestions"},{"location":"prep/","text":"Preparation \u00b6 Software \u00b6 To do this assignment you will need Python 3.x with Astropy , Sunpy , and IRISpy packages, plus Jupyter and many other dependencies of these packages. All the required software is already installed in the Institute's Linux machines, to which you can connect to. See the guide on how to use Python at ITA. Installing in your own laptop \u00b6 Installing in your laptop is optional. You will need to ensure you have all the required software installed. The easiest way to do this is using the miniconda or Anaconda Python distributions ( python 3.x versions ). Miniconda is recommended because it is a smaller download, but Anaconda works just as well if you already have it or are more familiar with it. Once you have conda installed (either a new install or an older version), the recommended way to install the packages is to create a new enviroment (we'll call it ast2210 ) to ensure you have the most recent versions. You can do this by: conda create -n ast2210 -c conda-forge --override-channels --yes \\ python = 3 .6 jupyterlab sunpy ndcube ipympl widgetsnbextension pip This will download about 160 MB and install all the needed dependencies. Next, you need to activate this environment: source activate ast2210 Warning Every time you want to use the newly installed python packages, you must ensure you are running from the ast2210 environment. Once active, your prompt will start with (ast2210) . If you open a new terminal, you will need to activate the environment again. IRISPy has to be installed manually from Github. Run the following from the terminal: pip install git+git://github.com/sunpy/irispy.git@master If using Jupyterlab, you will also need to install the extensions: jupyter labextension install @jupyter-widgets/jupyterlab-manager jupyter-matplotlib For running the examples and writing the assignment you should use Jupyter notebooks. A notebook is a document where you can combine text, images, and source code. If you are unfamiliar with Jupyter, there are several guides and tutorials . We recommend you use Jupyterlab , the next-generation version of Jupyter. But you can also use the classical notebook interface. Testing installation \u00b6 To make sure you have all necessary software ready, start Jupyterlab from the terminal (after activating the ast2210 environment): jupyter lab This will then open up a browser with the Jupyterlab launcher. Choose \"Python 3\" notebook, and it will start a new notebook. In the first cell enter the following and run: import sunpy.map import irispy.sji Success If you got no error messages above, your installation is good and you are ready to start! Downloading data \u00b6 To run the examples and complete this assignment you will have to download several hundreds of MB of data. Depending on your internet connection this may take a long time, so you should start early! You will need to download data from two space telescopes: AIA and IRIS. Astronomical file formats All the data files we will use are in the FITS format . FITS is an ancient file format developed for Astronomy, but is so standard that it is still in use by nearly all astronomical observatories. FITS files consist of a header with metadata about the observations, followed by a binary part with data. Depending on the type of observations, the sizes of FITS files can vary from a few KB to several TB. In the future, FITS will probably be replaced by the ASDF format. IRIS data \u00b6 You will need to download data from two IRIS datasets: 2014.09.19 Emerging sunspots (18 MB), 2832 SJI, see also IRIS event page 2015.03.19 Mysterious event at limb (572 MB), 1330 SJI, see also IRIS event page AIA data \u00b6 There are many ways to download AIA data. As part of the exercises, you will download AIA data from Python, so no data links are provided beforehand. Moreover, it will be part of the exercises to decide how much AIA data to download. At some point you will be free to choose which channels to download, how regularly to sample, etc. Each AIA file is about 10 MB. This does not seem a lot, but if you download one hour at maximum cadence for one channel, it adds to about 2.9 GB! So you will have to be careful with this.","title":"Preparation"},{"location":"prep/#preparation","text":"","title":"Preparation"},{"location":"prep/#software","text":"To do this assignment you will need Python 3.x with Astropy , Sunpy , and IRISpy packages, plus Jupyter and many other dependencies of these packages. All the required software is already installed in the Institute's Linux machines, to which you can connect to. See the guide on how to use Python at ITA.","title":"Software"},{"location":"prep/#installing-in-your-own-laptop","text":"Installing in your laptop is optional. You will need to ensure you have all the required software installed. The easiest way to do this is using the miniconda or Anaconda Python distributions ( python 3.x versions ). Miniconda is recommended because it is a smaller download, but Anaconda works just as well if you already have it or are more familiar with it. Once you have conda installed (either a new install or an older version), the recommended way to install the packages is to create a new enviroment (we'll call it ast2210 ) to ensure you have the most recent versions. You can do this by: conda create -n ast2210 -c conda-forge --override-channels --yes \\ python = 3 .6 jupyterlab sunpy ndcube ipympl widgetsnbextension pip This will download about 160 MB and install all the needed dependencies. Next, you need to activate this environment: source activate ast2210 Warning Every time you want to use the newly installed python packages, you must ensure you are running from the ast2210 environment. Once active, your prompt will start with (ast2210) . If you open a new terminal, you will need to activate the environment again. IRISPy has to be installed manually from Github. Run the following from the terminal: pip install git+git://github.com/sunpy/irispy.git@master If using Jupyterlab, you will also need to install the extensions: jupyter labextension install @jupyter-widgets/jupyterlab-manager jupyter-matplotlib For running the examples and writing the assignment you should use Jupyter notebooks. A notebook is a document where you can combine text, images, and source code. If you are unfamiliar with Jupyter, there are several guides and tutorials . We recommend you use Jupyterlab , the next-generation version of Jupyter. But you can also use the classical notebook interface.","title":"Installing in your own laptop"},{"location":"prep/#testing-installation","text":"To make sure you have all necessary software ready, start Jupyterlab from the terminal (after activating the ast2210 environment): jupyter lab This will then open up a browser with the Jupyterlab launcher. Choose \"Python 3\" notebook, and it will start a new notebook. In the first cell enter the following and run: import sunpy.map import irispy.sji Success If you got no error messages above, your installation is good and you are ready to start!","title":"Testing installation"},{"location":"prep/#downloading-data","text":"To run the examples and complete this assignment you will have to download several hundreds of MB of data. Depending on your internet connection this may take a long time, so you should start early! You will need to download data from two space telescopes: AIA and IRIS. Astronomical file formats All the data files we will use are in the FITS format . FITS is an ancient file format developed for Astronomy, but is so standard that it is still in use by nearly all astronomical observatories. FITS files consist of a header with metadata about the observations, followed by a binary part with data. Depending on the type of observations, the sizes of FITS files can vary from a few KB to several TB. In the future, FITS will probably be replaced by the ASDF format.","title":"Downloading data"},{"location":"prep/#iris-data","text":"You will need to download data from two IRIS datasets: 2014.09.19 Emerging sunspots (18 MB), 2832 SJI, see also IRIS event page 2015.03.19 Mysterious event at limb (572 MB), 1330 SJI, see also IRIS event page","title":"IRIS data"},{"location":"prep/#aia-data","text":"There are many ways to download AIA data. As part of the exercises, you will download AIA data from Python, so no data links are provided beforehand. Moreover, it will be part of the exercises to decide how much AIA data to download. At some point you will be free to choose which channels to download, how regularly to sample, etc. Each AIA file is about 10 MB. This does not seem a lot, but if you download one hour at maximum cadence for one channel, it adds to about 2.9 GB! So you will have to be careful with this.","title":"AIA data"},{"location":"sunpy_aia/","text":"Download this page as a Jupyter notebook. Sunpy and AIA data \u00b6 Sunpy is an open source Python package for solar physics. It allows you to interact, visualise and analyse different types of solar data. Here we will use it to work with AIA data. Initialisation \u00b6 Before we start, it is a good practice to place all your package imports and any special commands in the first code cell of your jupyter notebook. Here we will use the following: % matplotlib inline from matplotlib import pyplot as plt plt . rcParams [ 'figure.figsize' ] = [ 10 , 9 ] # make plots larger import sunpy.map from sunpy.instr.aia import aiaprep from sunpy.net import Fido , attrs as a from astropy.coordinates import SkyCoord from astropy import units as u import warnings warnings . filterwarnings ( \"ignore\" ) Searching and downloading data \u00b6 Now the next step is to actually get some data! We are going to use Sunpy to download some AIA data. There are several ways of acquiring data with Sunpy, and here we will use Fido to query the Virtual Solar Observatory (VSO). First we do a search to find out what AIA data are available on a time range, and the 171 channel: result = Fido . search ( a . Time ( '2014-09-19T05:59:00' , '2014-09-19T06:01:00' ), a . Instrument ( \"aia\" ), a . Wavelength ( 171 * u . angstrom ), a . vso . Sample ( 12 * u . second )) result Results from 1 Provider: 10 Results from the VSOClient: QTable length=10 Start Time [1] End Time [1] Source Instrument Type Wavelength [2] Angstrom str19 str19 str3 str3 str8 float64 2014-09-19 06:00:35 2014-09-19 06:00:36 SDO AIA FULLDISK 171.0 .. 171.0 2014-09-19 05:59:59 2014-09-19 06:00:00 SDO AIA FULLDISK 171.0 .. 171.0 2014-09-19 05:59:35 2014-09-19 05:59:36 SDO AIA FULLDISK 171.0 .. 171.0 2014-09-19 06:00:11 2014-09-19 06:00:12 SDO AIA FULLDISK 171.0 .. 171.0 2014-09-19 06:00:47 2014-09-19 06:00:48 SDO AIA FULLDISK 171.0 .. 171.0 2014-09-19 05:59:11 2014-09-19 05:59:12 SDO AIA FULLDISK 171.0 .. 171.0 2014-09-19 06:00:59 2014-09-19 06:01:00 SDO AIA FULLDISK 171.0 .. 171.0 2014-09-19 05:59:23 2014-09-19 05:59:24 SDO AIA FULLDISK 171.0 .. 171.0 2014-09-19 05:59:47 2014-09-19 05:59:48 SDO AIA FULLDISK 171.0 .. 171.0 2014-09-19 06:00:23 2014-09-19 06:00:24 SDO AIA FULLDISK 171.0 .. 171.0 In the above we used a.vso.Sample(12*u.second) , to make sure that the search looks for all images with a 12 second cadence (maximum for AIA). In this two minute interval, we see several observations but the cadence is not 12 seconds but around 36 seconds. This is because not all channels are exposed simultaneously (there are 10 channels and only 4 telescopes, so AIA cycles through the channels). So far have only queried the database. Now, let us download the file closest to 06:00 (4 th in sequence): file_download = Fido . fetch ( result [ 0 , 3 ], site = 'ROB' ) [ ======================================== Even though we requested only one file, the above may take a while to download. We used ROB for site, which is the Royal Observatorium of Belgium. If you have problems, you can also use MPS or KIS for site . Fido downloads the file(s) to a directory in your hard drive, typically in ~/sunpy/data . The locations of the file(s) are saved on the list file_download . In this case, it is: file_download ['/Users/tiago/sunpy/data/aia_20140919_060011_0171_image_lev1.fits'] Now let us load this file using Sunpy.map and check its metadata: aia1 = sunpy . map . Map ( file_download [ 0 ]) aia1 SunPy Map --------- Observatory: SDO Instrument: AIA 3 Detector: AIA Measurement: 171.0 Angstrom Wavelength: 171.0 Angstrom Observation Date: 2014-09-19 06:00:11 Exposure Time: 2.000196 s Dimension: [4096. 4096.] pix Coordinate System: helioprojective Scale: [0.59948897 0.59948897] arcsec / pix Reference Pixel: [2053. 2049.1001] pix Reference Coord: [0. 0.] arcsec array([[ 0, 0, 0, ..., 0, -1, -2], [ 2, 1, -1, ..., -1, 0, -1], [-1, -2, 1, ..., 0, 1, 1], ..., [-1, 0, -2, ..., -1, 1, -1], [ 0, 0, -2, ..., 2, 0, -2], [ 0, 0, -2, ..., -1, 3, 2]], dtype=int16) Data levels Data from space missions is classified according to different levels of calibration. From the time it is downloaded from the satellite to when you use it for scientific analysis, it undergoes many transformations. It is first saved as raw data, then placed into a FITS file with basic metadata, and later corrected for different effects such as flat fields, darks, geometry, reorganised into different files, etc. Some of these operations can be destructive (i.e. you can no longer go back to the raw data from the calibrated data), and that is why data are usually distributed in different levels. For science you want the highest possible level, but having a lower level can be useful in case the calibration procedure has improved. Different space missions have different data level numbers. For example, an AIA level 1 file is not the same as an IRIS level 1 file. Before proceeding with any scientific analysis, we need to perform some basic calibration on these data. Distributed AIA files are in the so-called \"level 1\" format, which has been flat-fielded, dark subtracted, de-spiked and corrected for bad pixels. However, additional calibration is necessary to correct for geometric effects, align the image axes with solar north, and place all channels in a common plate scale (spatial pixel size). This correction is called \"level 1.5\", and you should perform it for all files used in scientific work. To correct AIA to level 1.5 data, we use the aiaprep function that we previously imported: aia = aiaprep ( aia1 ) Working with Map objects \u00b6 We can now have a look at the data with the .plot () method: aia . plot () plt . colorbar () plt . show () We can now see the whole Sun at 17.1 nm on the chosen date. The .plot () method does several things in the background. It not only plots the image data, but also sets the image scale to be solar (x, y) coordinates, and automatically scales the image in a log scale (see color bar on left). Can you find two sunspots in the image? At this time there were two sunspots visible in the Sun. But you will hardly find them in the 171 image. This is because these images sample the Corona at almost 1 million K. This is well above the visible surface, which is where sunspots are better seen. More on this later. Alternatively, we can also plot the image manually using matplotlib's imshow() : fig , ax = plt . subplots () plt . imshow ( aia . data , cmap = 'gist_gray' ) plt . colorbar () <matplotlib.colorbar.Colorbar at 0x11d088e48> This basic plot lacks many of the useful features of Sunpy. We have the axes in pixels and not coordinates, linear scale, and a black and white colormap. You can read more about how to use Sunpy.map and plotting in the Guide to Sunpy . Working with coordinates \u00b6 Different coordinate systems exist for celestial bodies. On Earth, we are used to a Geographic coordinate system where a fixed location can always be located by longitude and latitude (e.g. Oslo is always at 59\u00b055\u20320\u2033N 10\u00b044\u20320\u2033E). The Sun is also approximately spherical, so we could similarly use Heliographic coordinates. However, these have several issues that make their general use difficult: As seen in the 171 image, many solar features such as jets and loops extend beyond the surface, so besides latitude and longitude we also need radius to describe a point, leading to projection effects Unlike Earth, the Sun does not rotate as a solid body, it has differential rotation , meaning the equator rotates faster than the poles. Therefore, points are not really fixed at different latitudes. The most used solar coordinates are instead Helioprojective cartesian, or solar XY coordinates. In these coordinates, the Sun is projected into an (x, y) plane as seen from Earth. The origin of this system is the solar disk centre, and they are typically in units of arcsecond (\u2033). With the solar radius being 959\u2033.63, the range of solar XY coordinates is typically from -1000\u2033 to 1000\u2033. You can read more about solar coordinate systems . In astronomy, coordinate systems are described by the World Coordinate System (WCS), and in Python this is handled by astropy's WCS module . The FITS files from AIA and IRIS have the coordinate information written as WCS metadata, which are then read by Sunpy to plot the correct coordinate axes in .plot () . Any transformation to the data is then aware of the coordinates. For example, we can rotate our Sunpy map by 45\u00b0 and see what happens with the output: aia_rot = aia . rotate ( 45 * u . deg ) aia_rot . plot () <matplotlib.image.AxesImage at 0x11d1bf7f0> Now the image has rotated, but so have the coordinates. This takes a while because the original image is huge (4096x4096), and the output is even larger. In fact, these AIA images are so large that when looking at the full disk we don't see the many small details. Sunpy allows us to create a submap, a subregion of a map. We can select this solar coordinates, and need to define the bottom left and top right corner coordinates of the region we want to select: top_right = SkyCoord ( - 550 * u . arcsec , 180 * u . arcsec , frame = aia . coordinate_frame ) bottom_left = SkyCoord ( - 900 * u . arcsec , - 80. * u . arcsec , frame = aia . coordinate_frame ) aia_sub = aia . submap ( top_right , bottom_left ) aia_sub . plot () <matplotlib.image.AxesImage at 0x11d202f28> This aia_sub image is much smaller than the original. Using multiple channels \u00b6 Now let us use the power of AIA and look at the same solar region, but closer to the photosphere. Let's search for and download the 1700 channel at about the same time: result = Fido . search ( a . Time ( '2014-09-19T05:59:00' , '2014-09-19T06:01:00' ), a . Instrument ( \"aia\" ), a . Wavelength ( 1700 * u . angstrom ), a . vso . Sample ( 12 * u . second )) # result closest in time to the 171 image: file_download = Fido . fetch ( result [ 0 , 2 ], site = 'ROB' ) aia1 = sunpy . map . Map ( file_download [ 0 ]) aia1700 = aiaprep ( aia1 ) aia1700_sub = aia1700 . submap ( top_right , bottom_left ) aia1700_sub . plot () [ ======================================== < matplotlib . image . AxesImage at 0 x128300b70 > Now you can see the sunspots! This 1700 image is a lot closer to the visible surface. It shows sunspots and also bright regions, which are caused by large magnetic fields. The 171 and 1700 images are so far apart that it is difficult to find common parts. We can use matplotlib to animate in between the two images: from matplotlib import animation from IPython.display import HTML fig , ax = plt . subplots () im1 = aia1700_sub . plot () im2 = aia_sub . plot () # add last image twice to avoid quick looping anim = animation . ArtistAnimation ( fig , [[ im1 ], [ im2 ], [ im1 ]], interval = 1000 , blit = True ) plt . close ( fig ) HTML ( anim . to_html5_video ()) Your browser does not support the video tag. Time evolution \u00b6 In the last exercise in this series we will look at a time series of AIA data. We want to see how these two sunspots came about, and how they evolve. Making use of Fido, we will download a series of AIA images and make a movie. In this example we will use 1700 images, but your are free to choose another channel if you want. Danger We are now entering into dangerous territory. You will write some code to download a series of images. If this is done incorrectly, you will end up downloading a HUGE volume of data. In the best case scenario you will have to wait for a long time for the code to finish. In the worst case scenario your IP may be blocked by the VSO for exceeding reasonable download limits, your hard drive will be 100% full and your computer will slow down to a halt. Before you run Fido.fetch() , double check how many files you are attempting to download (each file is ~10 MB), and use common sense when trying to download multiple files. What happens if you run Fido.fetch() twice? It will download the file(s) again. But it will not overwrite existing files, it will create a new version with a number at the end. E.g.: First run: aia_20140919_060030_1700_image_lev1.fits Second run: aia_20140919_060030_1700_image_lev1.0.fits Third run: aia_20140919_060030_1700_image_lev1.1.fits And so on... So use Fido.fetch() with care. Now we will download a sequence of 1700 images before and after the one above, for a interval of about 4 days and a cadence of 6 hours. Feel free to change the AIA channel and if you want, the cadence. The code below will download about 15 images, totalling about 180 MB . If you use a higher cadence, this might increase substantially, or alternatively you can choose a lower cadence to reduce the download size. result = Fido . search ( a . Time ( '2014-09-16T18:00:00' , '2014-09-20T07:00:00' ), a . Instrument ( \"aia\" ), a . Wavelength ( 1700 * u . angstrom ), a . vso . Sample ( 6 * u . hour )) result Results from 1 Provider: 15 Results from the VSOClient: QTable length=15 Start Time [1] End Time [1] Source Instrument Type Wavelength [2] Angstrom str19 str19 str3 str3 str8 float64 2014-09-19 00:00:30 2014-09-19 00:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-17 18:00:30 2014-09-17 18:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-17 06:00:30 2014-09-17 06:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-20 06:00:30 2014-09-20 06:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-18 00:00:30 2014-09-18 00:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-20 00:00:30 2014-09-20 00:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-18 12:00:30 2014-09-18 12:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-18 18:00:30 2014-09-18 18:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-19 06:00:30 2014-09-19 06:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-18 06:00:30 2014-09-18 06:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-16 18:00:30 2014-09-16 18:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-17 12:00:30 2014-09-17 12:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-17 00:00:30 2014-09-17 00:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-19 12:00:30 2014-09-19 12:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-19 18:00:30 2014-09-19 18:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 # Download ALL results (use with care!) file_download = Fido . fetch ( result , site = 'ROB' ) # sort by date file_download = sorted ( file_download ) # Load all files into a Map sequence tmp = sunpy . map . Map ( file_download ) [ ======================================== # In this case, we do not run aiaprep because we're only using one channel aia_seq = [] for img in tmp : top_right = SkyCoord ( - 550 * u . arcsec , 180 * u . arcsec , frame = img . coordinate_frame ) bottom_left = SkyCoord ( - 900 * u . arcsec , - 80. * u . arcsec , frame = img . coordinate_frame ) aia_seq . append ( img . submap ( top_right , bottom_left )) To save time not having to do this all the time, we are going to save the submaps into FITS files using the .save () method of the SunPy Map. First we create new filenames based on the downloaded files. new_files = [ a . split ( 'lev1' )[ 0 ] + 'lev1_sub.fits' for a in file_download ] for img , file_name in zip ( aia_seq , new_files ): img . save ( file_name ) And now we animate the sequence of all the images, loading from the submap files: aia = sunpy . map . Map ( new_files ) fig , ax = plt . subplots () # image half down sequence to get better scaling plot_obj = aia [ len ( aia ) // 2 ] . plot () def animate ( i ): ax . set_title ( \"AIA %s %s \" % ( aia [ i ] . meta [ 'wave_str' ], aia [ i ] . meta [ 't_obs' ][: - 8 ])) plot_obj . set_data ( aia [ i ] . data ) return ( plot_obj ,) anim = animation . FuncAnimation ( fig , animate , init_func = None , frames = len ( aia ), interval = 500 , blit = True ) plt . close ( fig ) HTML ( anim . to_html5_video ()) Your browser does not support the video tag. You should see above an animation of the sunspots evolving as the Sun rotates.","title":"Sunpy and AIA"},{"location":"sunpy_aia/#sunpy-and-aia-data","text":"Sunpy is an open source Python package for solar physics. It allows you to interact, visualise and analyse different types of solar data. Here we will use it to work with AIA data.","title":"Sunpy and AIA data"},{"location":"sunpy_aia/#initialisation","text":"Before we start, it is a good practice to place all your package imports and any special commands in the first code cell of your jupyter notebook. Here we will use the following: % matplotlib inline from matplotlib import pyplot as plt plt . rcParams [ 'figure.figsize' ] = [ 10 , 9 ] # make plots larger import sunpy.map from sunpy.instr.aia import aiaprep from sunpy.net import Fido , attrs as a from astropy.coordinates import SkyCoord from astropy import units as u import warnings warnings . filterwarnings ( \"ignore\" )","title":"Initialisation"},{"location":"sunpy_aia/#searching-and-downloading-data","text":"Now the next step is to actually get some data! We are going to use Sunpy to download some AIA data. There are several ways of acquiring data with Sunpy, and here we will use Fido to query the Virtual Solar Observatory (VSO). First we do a search to find out what AIA data are available on a time range, and the 171 channel: result = Fido . search ( a . Time ( '2014-09-19T05:59:00' , '2014-09-19T06:01:00' ), a . Instrument ( \"aia\" ), a . Wavelength ( 171 * u . angstrom ), a . vso . Sample ( 12 * u . second )) result Results from 1 Provider: 10 Results from the VSOClient: QTable length=10 Start Time [1] End Time [1] Source Instrument Type Wavelength [2] Angstrom str19 str19 str3 str3 str8 float64 2014-09-19 06:00:35 2014-09-19 06:00:36 SDO AIA FULLDISK 171.0 .. 171.0 2014-09-19 05:59:59 2014-09-19 06:00:00 SDO AIA FULLDISK 171.0 .. 171.0 2014-09-19 05:59:35 2014-09-19 05:59:36 SDO AIA FULLDISK 171.0 .. 171.0 2014-09-19 06:00:11 2014-09-19 06:00:12 SDO AIA FULLDISK 171.0 .. 171.0 2014-09-19 06:00:47 2014-09-19 06:00:48 SDO AIA FULLDISK 171.0 .. 171.0 2014-09-19 05:59:11 2014-09-19 05:59:12 SDO AIA FULLDISK 171.0 .. 171.0 2014-09-19 06:00:59 2014-09-19 06:01:00 SDO AIA FULLDISK 171.0 .. 171.0 2014-09-19 05:59:23 2014-09-19 05:59:24 SDO AIA FULLDISK 171.0 .. 171.0 2014-09-19 05:59:47 2014-09-19 05:59:48 SDO AIA FULLDISK 171.0 .. 171.0 2014-09-19 06:00:23 2014-09-19 06:00:24 SDO AIA FULLDISK 171.0 .. 171.0 In the above we used a.vso.Sample(12*u.second) , to make sure that the search looks for all images with a 12 second cadence (maximum for AIA). In this two minute interval, we see several observations but the cadence is not 12 seconds but around 36 seconds. This is because not all channels are exposed simultaneously (there are 10 channels and only 4 telescopes, so AIA cycles through the channels). So far have only queried the database. Now, let us download the file closest to 06:00 (4 th in sequence): file_download = Fido . fetch ( result [ 0 , 3 ], site = 'ROB' ) [ ======================================== Even though we requested only one file, the above may take a while to download. We used ROB for site, which is the Royal Observatorium of Belgium. If you have problems, you can also use MPS or KIS for site . Fido downloads the file(s) to a directory in your hard drive, typically in ~/sunpy/data . The locations of the file(s) are saved on the list file_download . In this case, it is: file_download ['/Users/tiago/sunpy/data/aia_20140919_060011_0171_image_lev1.fits'] Now let us load this file using Sunpy.map and check its metadata: aia1 = sunpy . map . Map ( file_download [ 0 ]) aia1 SunPy Map --------- Observatory: SDO Instrument: AIA 3 Detector: AIA Measurement: 171.0 Angstrom Wavelength: 171.0 Angstrom Observation Date: 2014-09-19 06:00:11 Exposure Time: 2.000196 s Dimension: [4096. 4096.] pix Coordinate System: helioprojective Scale: [0.59948897 0.59948897] arcsec / pix Reference Pixel: [2053. 2049.1001] pix Reference Coord: [0. 0.] arcsec array([[ 0, 0, 0, ..., 0, -1, -2], [ 2, 1, -1, ..., -1, 0, -1], [-1, -2, 1, ..., 0, 1, 1], ..., [-1, 0, -2, ..., -1, 1, -1], [ 0, 0, -2, ..., 2, 0, -2], [ 0, 0, -2, ..., -1, 3, 2]], dtype=int16) Data levels Data from space missions is classified according to different levels of calibration. From the time it is downloaded from the satellite to when you use it for scientific analysis, it undergoes many transformations. It is first saved as raw data, then placed into a FITS file with basic metadata, and later corrected for different effects such as flat fields, darks, geometry, reorganised into different files, etc. Some of these operations can be destructive (i.e. you can no longer go back to the raw data from the calibrated data), and that is why data are usually distributed in different levels. For science you want the highest possible level, but having a lower level can be useful in case the calibration procedure has improved. Different space missions have different data level numbers. For example, an AIA level 1 file is not the same as an IRIS level 1 file. Before proceeding with any scientific analysis, we need to perform some basic calibration on these data. Distributed AIA files are in the so-called \"level 1\" format, which has been flat-fielded, dark subtracted, de-spiked and corrected for bad pixels. However, additional calibration is necessary to correct for geometric effects, align the image axes with solar north, and place all channels in a common plate scale (spatial pixel size). This correction is called \"level 1.5\", and you should perform it for all files used in scientific work. To correct AIA to level 1.5 data, we use the aiaprep function that we previously imported: aia = aiaprep ( aia1 )","title":"Searching and downloading data"},{"location":"sunpy_aia/#working-with-map-objects","text":"We can now have a look at the data with the .plot () method: aia . plot () plt . colorbar () plt . show () We can now see the whole Sun at 17.1 nm on the chosen date. The .plot () method does several things in the background. It not only plots the image data, but also sets the image scale to be solar (x, y) coordinates, and automatically scales the image in a log scale (see color bar on left). Can you find two sunspots in the image? At this time there were two sunspots visible in the Sun. But you will hardly find them in the 171 image. This is because these images sample the Corona at almost 1 million K. This is well above the visible surface, which is where sunspots are better seen. More on this later. Alternatively, we can also plot the image manually using matplotlib's imshow() : fig , ax = plt . subplots () plt . imshow ( aia . data , cmap = 'gist_gray' ) plt . colorbar () <matplotlib.colorbar.Colorbar at 0x11d088e48> This basic plot lacks many of the useful features of Sunpy. We have the axes in pixels and not coordinates, linear scale, and a black and white colormap. You can read more about how to use Sunpy.map and plotting in the Guide to Sunpy .","title":"Working with Map objects"},{"location":"sunpy_aia/#working-with-coordinates","text":"Different coordinate systems exist for celestial bodies. On Earth, we are used to a Geographic coordinate system where a fixed location can always be located by longitude and latitude (e.g. Oslo is always at 59\u00b055\u20320\u2033N 10\u00b044\u20320\u2033E). The Sun is also approximately spherical, so we could similarly use Heliographic coordinates. However, these have several issues that make their general use difficult: As seen in the 171 image, many solar features such as jets and loops extend beyond the surface, so besides latitude and longitude we also need radius to describe a point, leading to projection effects Unlike Earth, the Sun does not rotate as a solid body, it has differential rotation , meaning the equator rotates faster than the poles. Therefore, points are not really fixed at different latitudes. The most used solar coordinates are instead Helioprojective cartesian, or solar XY coordinates. In these coordinates, the Sun is projected into an (x, y) plane as seen from Earth. The origin of this system is the solar disk centre, and they are typically in units of arcsecond (\u2033). With the solar radius being 959\u2033.63, the range of solar XY coordinates is typically from -1000\u2033 to 1000\u2033. You can read more about solar coordinate systems . In astronomy, coordinate systems are described by the World Coordinate System (WCS), and in Python this is handled by astropy's WCS module . The FITS files from AIA and IRIS have the coordinate information written as WCS metadata, which are then read by Sunpy to plot the correct coordinate axes in .plot () . Any transformation to the data is then aware of the coordinates. For example, we can rotate our Sunpy map by 45\u00b0 and see what happens with the output: aia_rot = aia . rotate ( 45 * u . deg ) aia_rot . plot () <matplotlib.image.AxesImage at 0x11d1bf7f0> Now the image has rotated, but so have the coordinates. This takes a while because the original image is huge (4096x4096), and the output is even larger. In fact, these AIA images are so large that when looking at the full disk we don't see the many small details. Sunpy allows us to create a submap, a subregion of a map. We can select this solar coordinates, and need to define the bottom left and top right corner coordinates of the region we want to select: top_right = SkyCoord ( - 550 * u . arcsec , 180 * u . arcsec , frame = aia . coordinate_frame ) bottom_left = SkyCoord ( - 900 * u . arcsec , - 80. * u . arcsec , frame = aia . coordinate_frame ) aia_sub = aia . submap ( top_right , bottom_left ) aia_sub . plot () <matplotlib.image.AxesImage at 0x11d202f28> This aia_sub image is much smaller than the original.","title":"Working with coordinates"},{"location":"sunpy_aia/#using-multiple-channels","text":"Now let us use the power of AIA and look at the same solar region, but closer to the photosphere. Let's search for and download the 1700 channel at about the same time: result = Fido . search ( a . Time ( '2014-09-19T05:59:00' , '2014-09-19T06:01:00' ), a . Instrument ( \"aia\" ), a . Wavelength ( 1700 * u . angstrom ), a . vso . Sample ( 12 * u . second )) # result closest in time to the 171 image: file_download = Fido . fetch ( result [ 0 , 2 ], site = 'ROB' ) aia1 = sunpy . map . Map ( file_download [ 0 ]) aia1700 = aiaprep ( aia1 ) aia1700_sub = aia1700 . submap ( top_right , bottom_left ) aia1700_sub . plot () [ ======================================== < matplotlib . image . AxesImage at 0 x128300b70 > Now you can see the sunspots! This 1700 image is a lot closer to the visible surface. It shows sunspots and also bright regions, which are caused by large magnetic fields. The 171 and 1700 images are so far apart that it is difficult to find common parts. We can use matplotlib to animate in between the two images: from matplotlib import animation from IPython.display import HTML fig , ax = plt . subplots () im1 = aia1700_sub . plot () im2 = aia_sub . plot () # add last image twice to avoid quick looping anim = animation . ArtistAnimation ( fig , [[ im1 ], [ im2 ], [ im1 ]], interval = 1000 , blit = True ) plt . close ( fig ) HTML ( anim . to_html5_video ()) Your browser does not support the video tag.","title":"Using multiple channels"},{"location":"sunpy_aia/#time-evolution","text":"In the last exercise in this series we will look at a time series of AIA data. We want to see how these two sunspots came about, and how they evolve. Making use of Fido, we will download a series of AIA images and make a movie. In this example we will use 1700 images, but your are free to choose another channel if you want. Danger We are now entering into dangerous territory. You will write some code to download a series of images. If this is done incorrectly, you will end up downloading a HUGE volume of data. In the best case scenario you will have to wait for a long time for the code to finish. In the worst case scenario your IP may be blocked by the VSO for exceeding reasonable download limits, your hard drive will be 100% full and your computer will slow down to a halt. Before you run Fido.fetch() , double check how many files you are attempting to download (each file is ~10 MB), and use common sense when trying to download multiple files. What happens if you run Fido.fetch() twice? It will download the file(s) again. But it will not overwrite existing files, it will create a new version with a number at the end. E.g.: First run: aia_20140919_060030_1700_image_lev1.fits Second run: aia_20140919_060030_1700_image_lev1.0.fits Third run: aia_20140919_060030_1700_image_lev1.1.fits And so on... So use Fido.fetch() with care. Now we will download a sequence of 1700 images before and after the one above, for a interval of about 4 days and a cadence of 6 hours. Feel free to change the AIA channel and if you want, the cadence. The code below will download about 15 images, totalling about 180 MB . If you use a higher cadence, this might increase substantially, or alternatively you can choose a lower cadence to reduce the download size. result = Fido . search ( a . Time ( '2014-09-16T18:00:00' , '2014-09-20T07:00:00' ), a . Instrument ( \"aia\" ), a . Wavelength ( 1700 * u . angstrom ), a . vso . Sample ( 6 * u . hour )) result Results from 1 Provider: 15 Results from the VSOClient: QTable length=15 Start Time [1] End Time [1] Source Instrument Type Wavelength [2] Angstrom str19 str19 str3 str3 str8 float64 2014-09-19 00:00:30 2014-09-19 00:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-17 18:00:30 2014-09-17 18:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-17 06:00:30 2014-09-17 06:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-20 06:00:30 2014-09-20 06:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-18 00:00:30 2014-09-18 00:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-20 00:00:30 2014-09-20 00:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-18 12:00:30 2014-09-18 12:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-18 18:00:30 2014-09-18 18:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-19 06:00:30 2014-09-19 06:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-18 06:00:30 2014-09-18 06:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-16 18:00:30 2014-09-16 18:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-17 12:00:30 2014-09-17 12:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-17 00:00:30 2014-09-17 00:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-19 12:00:30 2014-09-19 12:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 2014-09-19 18:00:30 2014-09-19 18:00:31 SDO AIA FULLDISK 1700.0 .. 1700.0 # Download ALL results (use with care!) file_download = Fido . fetch ( result , site = 'ROB' ) # sort by date file_download = sorted ( file_download ) # Load all files into a Map sequence tmp = sunpy . map . Map ( file_download ) [ ======================================== # In this case, we do not run aiaprep because we're only using one channel aia_seq = [] for img in tmp : top_right = SkyCoord ( - 550 * u . arcsec , 180 * u . arcsec , frame = img . coordinate_frame ) bottom_left = SkyCoord ( - 900 * u . arcsec , - 80. * u . arcsec , frame = img . coordinate_frame ) aia_seq . append ( img . submap ( top_right , bottom_left )) To save time not having to do this all the time, we are going to save the submaps into FITS files using the .save () method of the SunPy Map. First we create new filenames based on the downloaded files. new_files = [ a . split ( 'lev1' )[ 0 ] + 'lev1_sub.fits' for a in file_download ] for img , file_name in zip ( aia_seq , new_files ): img . save ( file_name ) And now we animate the sequence of all the images, loading from the submap files: aia = sunpy . map . Map ( new_files ) fig , ax = plt . subplots () # image half down sequence to get better scaling plot_obj = aia [ len ( aia ) // 2 ] . plot () def animate ( i ): ax . set_title ( \"AIA %s %s \" % ( aia [ i ] . meta [ 'wave_str' ], aia [ i ] . meta [ 't_obs' ][: - 8 ])) plot_obj . set_data ( aia [ i ] . data ) return ( plot_obj ,) anim = animation . FuncAnimation ( fig , animate , init_func = None , frames = len ( aia ), interval = 500 , blit = True ) plt . close ( fig ) HTML ( anim . to_html5_video ()) Your browser does not support the video tag. You should see above an animation of the sunspots evolving as the Sun rotates.","title":"Time evolution"}]}